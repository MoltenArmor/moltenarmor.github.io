<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.icku.eu.org","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概念解析CGroup，全称Control Group，是Linux内核提供的一种可以限制，记录，隔离进程组所使用资源的机制。它最初由Google提出，后被整合进Linux内核。它的功能包括：">
<meta property="og:type" content="article">
<meta property="og:title" content="CGroup v1 &amp;&amp; v2全解">
<meta property="og:url" content="https://blog.icku.eu.org/2024/03/31/CGroup-v1-v2%E5%85%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="MA Blog">
<meta property="og:description" content="概念解析CGroup，全称Control Group，是Linux内核提供的一种可以限制，记录，隔离进程组所使用资源的机制。它最初由Google提出，后被整合进Linux内核。它的功能包括：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.icku.eu.org/images/legacy-cgroup.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/unified-cgroup.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/legacy-cgroup-inherit.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/podman-user-slice.png">
<meta property="article:published_time" content="2024-03-31T04:08:39.000Z">
<meta property="article:modified_time" content="2024-06-27T15:16:10.000Z">
<meta property="article:author" content="Molten_Armor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.icku.eu.org/images/legacy-cgroup.png">


<link rel="canonical" href="https://blog.icku.eu.org/2024/03/31/CGroup-v1-v2%E5%85%A8%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.icku.eu.org/2024/03/31/CGroup-v1-v2%E5%85%A8%E8%A7%A3/","path":"2024/03/31/CGroup-v1-v2全解/","title":"CGroup v1 && v2全解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CGroup v1 && v2全解 | MA Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MA Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">概念解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8DCGroup%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">三种CGroup模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%EF%BC%88Legacy%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">传统模式（Legacy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%BC%8F%EF%BC%88Unified%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">统一模式（Unified）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Hybrid%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">混合模式（Hybrid）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGroup-v1"><span class="nav-number">2.</span> <span class="nav-text">CGroup v1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E6%8E%A7%E5%88%B6%E5%99%A8cpu"><span class="nav-number">2.1.</span> <span class="nav-text">CPU控制器cpu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E5%86%85%E5%AD%98%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%99%A8cpuset"><span class="nav-number">2.2.</span> <span class="nav-text">CPU&#x2F;内存节点控制器cpuset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E7%BB%9F%E8%AE%A1%E6%8E%A7%E5%88%B6%E5%99%A8cpuacct"><span class="nav-number">2.3.</span> <span class="nav-text">CPU统计控制器cpuacct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8memory"><span class="nav-number">2.4.</span> <span class="nav-text">内存控制器memory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%99%A8pids"><span class="nav-number">2.5.</span> <span class="nav-text">进程控制器pids</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87IO%E6%8E%A7%E5%88%B6%E5%99%A8blkio"><span class="nav-number">2.6.</span> <span class="nav-text">块设备IO控制器blkio</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E8%BD%BDCGroup-v1"><span class="nav-number">2.7.</span> <span class="nav-text">挂载CGroup v1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cgroup-tools"><span class="nav-number">2.8.</span> <span class="nav-text">cgroup-tools</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGroup-v2"><span class="nav-number">3.</span> <span class="nav-text">CGroup v2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">其他控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU%E6%8E%A7%E5%88%B6%E5%99%A8cpu-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">CPU控制器cpu</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU-%E5%86%85%E5%AD%98%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%99%A8cpuset-1"><span class="nav-number">3.1.2.</span> <span class="nav-text">CPU&#x2F;内存节点控制器cpuset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8memory-1"><span class="nav-number">3.1.3.</span> <span class="nav-text">内存控制器memory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8io"><span class="nav-number">3.1.4.</span> <span class="nav-text">IO控制器io</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%99%A8pids-1"><span class="nav-number">3.1.5.</span> <span class="nav-text">进程控制器pids</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E5%AD%98%E9%A1%B5%E6%8E%A7%E5%88%B6%E5%99%A8hugetlb"><span class="nav-number">3.1.6.</span> <span class="nav-text">大内存页控制器hugetlb</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E5%A4%A7%E8%A7%84%E5%88%99"><span class="nav-number">3.2.</span> <span class="nav-text">两大规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGroup-v2%E4%B8%8Esystemd"><span class="nav-number">3.3.</span> <span class="nav-text">CGroup v2与systemd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A7%94%E6%B4%BE%EF%BC%88Delegation%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">委派（Delegation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="nav-number">3.5.</span> <span class="nav-text">三种场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-number">3.6.</span> <span class="nav-text">控制器支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%AE%B9%E5%99%A8%E8%BD%BD%E8%8D%B7%E7%9A%84systemd"><span class="nav-number">3.7.</span> <span class="nav-text">作为容器载荷的systemd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%EF%BC%9A%E6%89%93%E7%A0%B4%E8%A7%84%E5%88%992"><span class="nav-number">3.9.</span> <span class="nav-text">附：打破规则2</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Molten_Armor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/MoltenArmor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MoltenArmor" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kwokjuy@163.com" title="E-Mail → mailto:kwokjuy@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.icku.eu.org/2024/03/31/CGroup-v1-v2%E5%85%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Molten_Armor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MA Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CGroup v1 && v2全解 | MA Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CGroup v1 && v2全解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-31 12:08:39" itemprop="dateCreated datePublished" datetime="2024-03-31T12:08:39+08:00">2024-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-27 23:16:10" itemprop="dateModified" datetime="2024-06-27T23:16:10+08:00">2024-06-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h3><p>CGroup，全称Control Group，是Linux内核提供的一种可以限制，记录，隔离<strong>进程组</strong>所使用资源的机制。它最初由Google提出，后被整合进Linux内核。它的功能包括：</p>
<span id="more"></span>
<ul>
<li>资源限制（Resource limiting）：CGroup可以对进程组使用的资源总额进行限制。如对特定的进程进行内存使用上限限制，当超出上限时，会触发OOM。</li>
<li>优先级分配（Prioritization）：通过分配的CPU时间片数量及硬盘IO带宽大小，实际上就相当于控制了进程运行的优先级。</li>
<li>资源统计（Accounting）：CGroup可以统计系统的资源使用量，如CPU使用时长、内存用量等等，这个功能非常适用于计费。</li>
<li>进程控制（Control）：CGroup可以对进程组执行挂起、恢复等操作。</li>
</ul>
<p>首先我们明确几个概念：</p>
<ul>
<li>Task：系统中的一个进程。</li>
<li>Subsystem：一个已经实现的资源控制器（Resource Controller）。</li>
<li>Hirerarchy：文件系统中的一个目录，或者说CGroup树中的一个节点。</li>
</ul>
<p>然后我们需要知道<strong>CGroup是存在两个不同版本的：V1和V2</strong>。</p>
<h4 id="三种CGroup模式"><a href="#三种CGroup模式" class="headerlink" title="三种CGroup模式"></a>三种CGroup模式</h4><h5 id="传统模式（Legacy）"><a href="#传统模式（Legacy）" class="headerlink" title="传统模式（Legacy）"></a>传统模式（Legacy）</h5><p>传统的CGroup v1模式。在CGroup v1中，原理上允许在每个目录上挂载任意数量的控制器，但是，每个控制器只能有一个实例（只能挂载一次），这种方式看上去很灵活，但是实际上并不是很有用。</p>
<ul>
<li>分开挂载会导致用户在多个非常相似的层级结构上重复进行非常相似的操作，这很浪费精力而且没什么必要。</li>
<li>到底哪些控制器会挂载在一起这件事本身是无法确定的，所以控制器必须假定在与其他控制器完全正交的环境下进行开发，这潜在地阻碍了控制器之间的协作。</li>
</ul>
<p>虽然如此，大部分发行版的实践还是创建一个<code>tmpfs</code>并挂载到<code>/sys/fs/cgroup/</code>，然后把<code>/proc/cgroups</code>中暴露出的所有支持的控制器分别以挂载在该目录下以该控制器命名的，分散的，互相正交的目录下：</p>
<p><img src="/images/legacy-cgroup.png" alt="legacy-cgroup.png"></p>
<p>为了进行管理，systemd也会挂载自己的根CGroup文件系统到<code>/sys/fs/cgroup/systemd</code>。</p>
<h5 id="统一模式（Unified）"><a href="#统一模式（Unified）" class="headerlink" title="统一模式（Unified）"></a>统一模式（Unified）</h5><p>systemd主导且大力推行的纯CGroup v2模式，在这种模式下，所有的资源控制器都被集成到一个唯一的，类型为<code>cgroup2</code>的，<code>/sys/fs/cgroup</code>根目录下：</p>
<p><img src="/images/unified-cgroup.png" alt="unified-cgroup.png"></p>
<p>在这种模式下，这个<code>cgroup2</code>文件系统本身就是<strong>systemd控制</strong>的。</p>
<h5 id="混合模式（Hybrid）"><a href="#混合模式（Hybrid）" class="headerlink" title="混合模式（Hybrid）"></a>混合模式（Hybrid）</h5><p>处于传统与统一模式之间的模式。这个模式大部分与传统模式一致，但是会额外将CGroup v2文件系统挂载到<code>/sys/fs/cgroup/unified</code>，不过需要注意，该模式下并没有使用CGroup v2的单一控制器，仍然使用分散的资源控制器。</p>
<p>必须强调：传统模式和混合模式仅仅只是权宜之计，应当尽可能地抛弃。</p>
<p>我们分别针对不同的模式进行分析：</p>
<h3 id="CGroup-v1"><a href="#CGroup-v1" class="headerlink" title="CGroup v1"></a>CGroup v1</h3><p>在CGroup v1中，对进程的控制需要通过在每个控制器的根CGroup目录中创建子目录实现。子目录在创建时，会自动地继承该控制器的根CGroup目录中的任何配置文件，就像这样：</p>
<p><img src="/images/legacy-cgroup-inherit.png" alt="legacy-cgroup-inherit.png"></p>
<p>所有控制器的根CGroup目录下，都会包含以下共同文件：</p>
<ul>
<li><code>tasks</code>：该CGroup目录当前正在管理的所有进程PID。</li>
<li><code>cgroup.procs</code>：纳入该CGroup目录管理的所有进程PID。这些进程的子进程也会被自动地加入<code>tasks</code>。该文件可以修改权限以进行权限下放。</li>
<li><code>cgroup.clone_children</code>：该文件的内容要么是<code>0</code>，要么是<code>1</code>。设为<code>1</code>时，子CGroup会继承父CGroup的配置。默认情况下，创建嵌套的子CGroup目录时，会采用默认值。</li>
<li><code>cgroup.sane_behavior</code>：该文件没有实际功能，也不可修改，它的存在仅仅表明该CGroup使用了Sane Behavior模式。</li>
<li><code>notify_on_release</code>：该文件的内容要么是<code>0</code>，要么是<code>1</code>。设为<code>1</code>时，当该CGroup中最后一个进程退出时，会执行<code>release_agent</code>脚本。</li>
<li><code>release_agent</code>：执行清理动作的辅助脚本。</li>
</ul>
<p>不同子系统（资源控制器）的特定配置项分别有：</p>
<h4 id="CPU控制器cpu"><a href="#CPU控制器cpu" class="headerlink" title="CPU控制器cpu"></a>CPU控制器<code>cpu</code></h4><ul>
<li><code>cpu.shares</code>：相对CPU权重，默认值为<code>1024</code>，调大会增加分配的CPU时间，反之减少。</li>
<li><code>cpu.cfs_period_us</code>：完全公平调度器（CFS）的评估周期，单位为微秒，取值范围为1毫秒到1秒。默认值为100000。</li>
<li><code>cpu.cfs_quota_us</code>：在<code>cpu.cfs_period_us</code>的周期内，允许使用的最大CPU时间，单位也是微秒。默认值为-1，表示不限制。</li>
<li><code>cpu.stat</code>：只读文件，记录了CPU的使用情况，包含三个字段：<ul>
<li><code>nr_periods</code>：经过了多少个CFS评估周期。</li>
<li><code>nr_throttled</code>：被节流的次数。</li>
<li><code>throttled_time</code>：被节流的总时长，单位为纳秒。</li>
</ul>
</li>
</ul>
<h4 id="CPU-内存节点控制器cpuset"><a href="#CPU-内存节点控制器cpuset" class="headerlink" title="CPU&#x2F;内存节点控制器cpuset"></a>CPU&#x2F;内存节点控制器<code>cpuset</code></h4><ul>
<li><code>cpuset.cpus</code>：允许使用的CPU节点，连续的节点间可以使用<code>-</code>连接。</li>
<li><code>cpuset.mems</code>：允许使用的内存节点，连续的节点间可以使用<code>-</code>连接。</li>
<li><code>cpuset.cpu_exclusive</code>：在同一时间内，是否不允许其他CGroup的进程与其共享同一CPU节点。</li>
<li><code>cpuset.mem_exclusive</code>：在同一时间内，是否不允许其他CGroup的进程与其共享同一内存节点。</li>
<li><code>cpuset.sched_load_balance</code>：是否允许在允许使用的CPU节点上进行负载均衡。默认为0。</li>
<li><code>cpuset.memory_spread_page</code>：是否将内核的页缓存均衡到允许使用的内存节点上。默认为0。</li>
<li><code>cpuset.memory_spread_slab</code>：是否将内核的Slab缓存均衡到允许使用的内存节点上。默认为0。</li>
<li><code>cpuset.memory_migrate</code>：是否允许进行内存迁移。默认为0。</li>
<li><code>cpuset.memory_pressure_enabled</code>：是否监测内存压力指数。默认为0。</li>
<li><code>cpuset.memory_pressure</code>：内存压力指数。</li>
</ul>
<h4 id="CPU统计控制器cpuacct"><a href="#CPU统计控制器cpuacct" class="headerlink" title="CPU统计控制器cpuacct"></a>CPU统计控制器<code>cpuacct</code></h4><p>该控制器的CGroup下的配置文件全部为只读。</p>
<ul>
<li><code>cpuacct.stat</code>：所有任务消耗的用户态和内核态CPU时间。</li>
<li><code>cpuacct.usage</code>：消耗的总CPU时间。</li>
<li><code>cpuacct.usage_sys</code>：消耗在内核态的总CPU时间。</li>
<li><code>cpuacct.usage_user</code>：消耗在用户态的总CPU时间。</li>
<li><code>cpuacct.percpu</code>：消耗的每个核心上的CPU时间。</li>
<li><code>cpuacct.percpu_sys</code>：在内核态消耗的每个核心上的CPU时间。</li>
<li><code>cpuacct.percpu_user</code>：在用户态消耗的每个核心上的CPU时间。</li>
<li><code>cpuacct.usage_all</code>：消耗的每个核心上的用户态和内核态CPU时间。</li>
</ul>
<h4 id="内存控制器memory"><a href="#内存控制器memory" class="headerlink" title="内存控制器memory"></a>内存控制器<code>memory</code></h4><ul>
<li><code>memory.usage_in_bytes</code>：当前的内存用量。</li>
<li><code>memory.stat</code>：内存的使用情况。</li>
<li><code>memory.force_empty</code>：不可读文件，任何写入都会触发强制触发换页。</li>
<li><code>memory.swappiness</code>：设置Swappiness。</li>
<li><code>memory.numa_stat</code>：NUMA节点的统计信息。</li>
<li><code>memory.max_usage_in_bytes</code>：历史最高内存用量。</li>
<li><code>memory.soft_limit_in_bytes</code>：设置内存软限制，打破该限制会导致记录。默认为内存最大值。</li>
<li><code>memory.limit_in_bytes</code>：设置内存硬限制，打破该限制会立刻触发OOM Killer。默认为内存最大值。</li>
<li><code>memory.failcnt</code>：打破限制的次数。</li>
<li><code>memory.oom_control</code>：OOM情况记录，包含三个字段：<ul>
<li><code>oom_kill_disable</code>：是否禁用OOM Killer，默认为0。</li>
<li><code>under_oom</code>：只读字段，是否正在触发OOM。</li>
<li><code>oom_kill</code>：只读字段，触发OOM Kill的次数。</li>
</ul>
</li>
<li><code>memory.memsw.max_usage_in_bytes</code>、<code>memory.memsw.soft_limit_in_bytes</code>、<code>memory.memsw.limit_in_bytes</code>、<code>memory.memsw.failcnt</code>：与<code>memory.*</code>对应的配置项相同，但是用于内存+交换空间的总和。</li>
<li><code>memory.kmem.max_usage_in_bytes</code>、<code>memory.kmem.soft_limit_in_bytes</code>、<code>memory.kmem.limit_in_bytes</code>、<code>memory.kmem.failcnt</code>：与<code>memory.*</code>对应的配置项相同，但是用于内核内存。</li>
</ul>
<h4 id="进程控制器pids"><a href="#进程控制器pids" class="headerlink" title="进程控制器pids"></a>进程控制器<code>pids</code></h4><p>这个控制器的根CGroup目录下没有配置文件，必须创建子CGroup目录后才能生成，你可以想一下为什么。</p>
<ul>
<li><code>pids.max</code>：该CGroup中允许的最大进程数量。默认为<code>max</code>表示不设限制。</li>
<li><code>pids.current</code>：只读文件，当前该CGroups中的进程数。</li>
<li><code>pids.peak</code>：只读文件，该CGroups中的最大进程数。</li>
<li><code>pids.events</code>：只读文件，记录<code>fork()</code>调用失败的次数。</li>
</ul>
<h4 id="块设备IO控制器blkio"><a href="#块设备IO控制器blkio" class="headerlink" title="块设备IO控制器blkio"></a>块设备IO控制器<code>blkio</code></h4><ul>
<li><code>blkio.reset_stats</code>：不可读文件，任何写入都会触发重置IO统计。</li>
<li><code>blkio.throttle.io_serviced</code>：在具体设备中的IO操作数，格式为<code>主设备号:从设备号 操作 数量</code>。</li>
<li><code>blkio.throttle.io_service_bytes</code>：在具体设备中的IO操作字节数，格式为<code>主设备号:从设备号 操作 字节数</code>。</li>
<li><code>blkio.throttle.read_iops_device</code>：在具体设备中每秒执行读操作数的上限，格式为<code>主设备号:从设备号 次数</code>。</li>
<li><code>blkio.throttle.read_bps_device</code>：在具体设备中每秒执行读操作字节的上限，格式为<code>主设备号:从设备号 字节数</code>。</li>
<li><code>blkio.throttle.write_iops_device</code>：在具体设备中每秒执行写操作数的上限，格式为<code>主设备号:从设备号 次数</code>。</li>
<li><code>blkio.throttle.write_bps_device</code>：在具体设备中每秒执行写操作字节的上限，格式为<code>主设备号:从设备号 字节数</code>。</li>
</ul>
<h4 id="挂载CGroup-v1"><a href="#挂载CGroup-v1" class="headerlink" title="挂载CGroup v1"></a>挂载CGroup v1</h4><p>systemd内置了挂载CGroup的功能且对其高度依赖，有两个内核目录行参数可以修改systemd挂载CGroup的行为：</p>
<ul>
<li><code>systemd.unified_cgroup_hierarchy</code>：是否允许回退到CGroup v1，设为<code>no</code>表示允许，设为<code>yes</code>表示不允许。如果Linux内核版本低于4.5，那么完全不支持CGroup v2，该内核命令行参数也就没有意义。</li>
<li><code>systemd.legacy_systemd_cgroup_controller</code>：是否允许混合使用CGroup控制器，该配置项在前一个配置项为<code>no</code>时才有意义，设为<code>no</code>表示不允许，即强制要求使用CGroup v1。</li>
</ul>
<p>OpenRC内置了名为<code>cgroups</code>的CGroup挂载脚本。</p>
<p>SysVinit需要编写额外的init脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Devuan</span><br><span class="line">apt install cgroupfs-mount</span><br></pre></td></tr></table></figure>

<p>手动挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># CGroup v1</span><br><span class="line"># 统一挂载，这会把所有的控制器全部挂载到该目录下</span><br><span class="line">mount -t cgroup none /sys/fs/cgroup</span><br><span class="line"></span><br><span class="line"># 正交挂载</span><br><span class="line">mount -t tmpfs cgroup /sys/fs/cgroup</span><br><span class="line"># 检查/proc/cgroups获取所有支持的控制器</span><br><span class="line">mount -t cgroup -o 控制器 none /sys/fs/cgroup/控制器名</span><br><span class="line"></span><br><span class="line"># CGroup v2</span><br><span class="line">mount -t cgroup2 none /sys/fs/cgroup</span><br></pre></td></tr></table></figure>

<h4 id="cgroup-tools"><a href="#cgroup-tools" class="headerlink" title="cgroup-tools"></a>cgroup-tools</h4><p><code>cgroup-tools</code>实际上是一组操作CGroup目录的工具。安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Devuan</span><br><span class="line">apt install cgroup-tools</span><br></pre></td></tr></table></figure>
<p>它提供的工具有：</p>
<ul>
<li><code>cgcreate -g 控制器:/CGroup目录 -a 拥有者:拥有组</code>：创建CGroup目录。</li>
<li><code>cgdelete -g 控制器:/CGroup目录 [-r]</code>：删除CGroup目录。</li>
<li><code>lscgroup</code>：列出CGroup目录情况。</li>
<li><code>cgexec -g 控制器:/CGroup目录 程序 [参数]</code>：在指定CGroup目录下运行程序。</li>
<li><code>cgclassify -g 控制器:/CGroup目录 PID</code>：将指定进程移动到指定CGroup目录下。</li>
</ul>
<h3 id="CGroup-v2"><a href="#CGroup-v2" class="headerlink" title="CGroup v2"></a>CGroup v2</h3><p>CGroup v2的组织结构和CGroup v1完全不同，它<strong>不再允许资源控制器独立挂载</strong>在分散的目录（并使用这些目录作为自己的根CGroup目录），转而<strong>强制采用</strong>一个单一的根CGroup目录（根节点），根CGroup目录下直接就包含了所有类型控制器的配置项。当然，创建子CGroup目录时也会继承上级所有控制器的默认配置项，不属于任何控制器的配置文件包括：</p>
<ul>
<li><code>cgroup.controllers</code>：包含的所有控制器类型。</li>
<li><code>cgroup.procs</code>：该CGroup目录当前正在管理的所有进程PID。</li>
<li><code>cgroup.threads</code>：该CGroup目录当前正在管理的所有线程ID。</li>
<li><code>cgroup.stat</code>：该CGroup目录的统计信息，包括：<ul>
<li><code>nr_descendants</code>：直接子CGroup的数量。</li>
<li><code>nr_dying_descendants</code>：濒临删除的直接子CGroup的数量。</li>
</ul>
</li>
<li><code>cgroup.subtree_control</code>：允许子CGroup目录使用的所有控制器类型。</li>
<li><code>cgroup.max.depth</code>：允许子CGroup目录的最大深度，默认为<code>max</code>。</li>
<li><code>cgroup.max.descendants</code>：允许子CGroup目录的最大数量，默认为<code>max</code>。</li>
<li><code>cgroup.pressure</code>：是否启用PSI统计功能。</li>
</ul>
<p>以下配置文件不会出现在根CGroup目录：</p>
<ul>
<li><code>cgroup.type</code>：该CGroup的类型，包括：<ul>
<li><code>domain</code>：正常的CGroup节点。</li>
<li><code>domain threaded</code>：包含一系列类型为<code>threaded</code>的CGroup子节点的父节点。</li>
<li><code>threaded</code>：线程CGroup节点，该CGroup目录不控制进程，而是控制一系列线程，用于实现线程级控制。</li>
</ul>
</li>
<li><code>cgroup.events</code>：只读文件，记录CGroup事件，字段包括：<ul>
<li><code>populated</code>：该CGroup及其子CGroup中是否包含任何存活进程。</li>
<li><code>frozen</code>：该CGroup是否被冻结。</li>
</ul>
</li>
<li><code>cgroup.freeze</code>：是否冻结该CGroup。默认为0。</li>
<li><code>cgroup.kill</code>：只写文件，任何写入都会导致该CGroup及其子CGroup立刻被杀死。</li>
</ul>
<h4 id="其他控制器"><a href="#其他控制器" class="headerlink" title="其他控制器"></a>其他控制器</h4><p>参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Control Group v2</a>。</p>
<h5 id="CPU控制器cpu-1"><a href="#CPU控制器cpu-1" class="headerlink" title="CPU控制器cpu"></a>CPU控制器<code>cpu</code></h5><ul>
<li><code>cpu.stat</code>：CPU统计情况，包含三个字段。<ul>
<li><code>usage_usec</code>：累计使用的CPU时间。单位为微秒。</li>
<li><code>user_usec</code>：累计在用户态使用的CPU时间。单位为微秒。</li>
<li><code>system_usec</code>：累计在内核态使用的CPU时间。单位为微秒。</li>
<li><code>nr_periods</code>：经过了多少个CFS评估周期。</li>
<li><code>nr_throttled</code>：被节流的次数。</li>
<li><code>throttled_usec</code>：被节流的总时长，单位为微秒。</li>
<li><code>nr_bursts</code>：发生Burst的总次数。</li>
<li><code>burst_usec</code>：Burst状态下累计使用的CPU时间。</li>
</ul>
</li>
<li><code>cpu.pressure</code>：CPU的PSI统计信息。</li>
<li><code>cpu.max</code>：最大CPU带宽。</li>
<li><code>cpu.max.burt</code>：最大CPU突发带宽。</li>
<li><code>cpu.idle</code>：是否为该CGroup设置低调度优先级。</li>
<li><code>cpu.weight</code>：相对CPU权重，取值范围在1-10000，如果<code>cpu.idle</code>的值为1，那么该文件的值会被设为0。</li>
<li><code>cpu.weight.nice</code>：CPU的Nice值，这是<code>cpu.weight</code>的一种替代接口，用类似于Nice的方式进行配置。</li>
</ul>
<h5 id="CPU-内存节点控制器cpuset-1"><a href="#CPU-内存节点控制器cpuset-1" class="headerlink" title="CPU&#x2F;内存节点控制器cpuset"></a>CPU&#x2F;内存节点控制器<code>cpuset</code></h5><p>这个控制器的配置文件不会出现在用户级的CGroup目录中。</p>
<ul>
<li><code>cpuset.cpus</code>：允许使用的CPU节点，连续的节点间可以使用<code>-</code>连接。</li>
<li><code>cpuset.cpus.effective</code>：目前正在使用的CPU节点，它应当是<code>cpuset.cpus</code>的子集，值会受到CPU热插拔事件影响。</li>
<li><code>cpuset.cpus.partitions</code>：可选值有<code>root</code>、<code>member</code>，是否将当前的CGroup放在一个独立的域中进行调度，如果设为<code>root</code>，那么该CGroup的<code>cpuset.cpus</code>会从上一级的<code>cpuset.cpus.effective</code>去掉。</li>
<li><code>cpuset.mems</code>：允许使用的内存节点，连续的节点间可以使用<code>-</code>连接。</li>
<li><code>cpuset.mems.effective</code>：目前正在使用的内存节点，它应当是<code>cpuset.mems</code>的子集，值会受到内存节点热插拔事件影响。</li>
</ul>
<h5 id="内存控制器memory-1"><a href="#内存控制器memory-1" class="headerlink" title="内存控制器memory"></a>内存控制器<code>memory</code></h5><ul>
<li><code>memory.current</code>：只读文件，记录当前该CGroup及其所有子CGroup使用的内存总量。</li>
<li><code>memory.min</code>：最低内存保障值的硬限制。如果该CGroup的内存用量小于此处的保障值，那么该CGroup的内存将会拒绝被回收。</li>
<li><code>memory.low</code>：最低内存保障值的软限制。如果该CGroup的内存用量小于此处的保障值，那么只要还能从其他地方回收内存，该CGroup的内存就会拒绝被回收。</li>
<li><code>memory.high</code>：最高内存用量的软限制。如果该CGroup的内存用量打破此处的限制，进程的运行速度将会大打折扣，并且系统会尽可能地迅速回收该CGroup的内存。</li>
<li><code>memory.pressure</code>：内存的PSI统计信息。</li>
<li><code>memory.max</code>：最高内存用量的硬限制。如果该CGroup的内存用量打破此处的限制，将立刻导致进程触发OOM Killer。</li>
<li><code>memory.reclaim</code>：只写文件，接受任何内存单位（如<code>1G</code>），写入后会触发该CGroup重新申请指定量的内存。</li>
<li><code>memory.peak</code>：只读文件，记录该CGroup及其所有子CGroup的内存用量峰值。</li>
<li><code>memory.oom.group</code>：该CGroup是否被OOM Killer视为一个整体，如果值为1，那么当触发OOM Killer时，该CGroup及其子CGroup中的所有进程总是被一起杀死。</li>
<li><code>memory.events</code>：只读文件，记录该CGroup及其子CGroup触发的内存事件，字段包括：<ul>
<li><code>low</code>：触及<code>memory.low</code>限制的次数。</li>
<li><code>high</code>：触及<code>memory.high</code>限制的次数。</li>
<li><code>max</code>：触及<code>memory.max</code>限制的次数。</li>
<li><code>oom</code>：触发OOM的次数。</li>
<li><code>oom_kill</code>：被OOM Killer杀死的进程数。</li>
<li><code>oom_group_kill</code>：被OOM Killer全部杀死的次数。</li>
</ul>
</li>
<li><code>memory.events.local</code>：只读文件，只属于当前层级的<code>memory.events</code>记录。</li>
<li><code>memory.stat</code>：只读文件，内存统计情况，详略。</li>
<li><code>memory.numa_stat</code>：只读文件，记录在每个NUMA内存节点上的内存用量。</li>
<li><code>memory.swap.current</code>：只读文件，当前的交换空间用量。</li>
<li><code>memory.swap.peak</code>：只读文件，记录该CGroup及其所有子CGroup的交换空间用量峰值。</li>
<li><code>memory.swap.high</code>：交换空间的最大用量的软限制。超过该用量会导致进程的运行速度大打折扣。</li>
<li><code>memory.swap.max</code>：交换空间的最大用量的硬限制。超过该用量会导致禁止进行换页。</li>
<li><code>memory.swap.events</code>：只读文件，记录该CGroup及其子CGroup触发的交换空间事件，字段如下：<ul>
<li><code>high</code>：触及<code>memory.swap.high</code>限制的次数。</li>
<li><code>max</code>：触及<code>memory.swap.max</code>限制的次数。</li>
<li><code>fail</code>：被禁止换页的次数。</li>
</ul>
</li>
<li><code>memory.zswap.current</code>：只读文件，当前的ZSwap用量。</li>
<li><code>memory.zswap.max</code>：ZSwap的最大用量的硬限制。超过该用量会导致禁止继续使用。</li>
<li><code>memory.zswap.writeback</code>：是否允许ZSwap回写，设为0会禁止。</li>
</ul>
<h5 id="IO控制器io"><a href="#IO控制器io" class="headerlink" title="IO控制器io"></a>IO控制器<code>io</code></h5><ul>
<li><code>io.stat</code>：IO统计信息，包含以下字段：<ul>
<li><code>rbytes</code>：读取字节数。</li>
<li><code>wbytes</code>：写入字节数。</li>
<li><code>rios</code>：读取次数。</li>
<li><code>wios</code>：写入次数。</li>
<li><code>dbytes</code>：抛弃字节数。</li>
<li><code>dios</code>：抛弃次数。</li>
</ul>
</li>
<li><code>io.pressure</code>：IO的PSI统计信息。</li>
<li><code>io.cost.qos</code>：配置IO的QoS，详略。</li>
<li><code>io.cost.model</code>：配置IO的消耗模型，详略。</li>
<li><code>io.weight</code>：IO的相对优先级，格式为<code>主设备号:从设备号 优先级</code>，值的范围为1-10000。</li>
<li><code>io.max</code>：最大IO速度，格式为<code>主设备号:从设备号 rbps=最大每秒读取字节数 wbps=最大每秒写入字节数 riops=最大每秒读取次数 wiops=最大每秒写入次数</code>。</li>
</ul>
<h5 id="进程控制器pids-1"><a href="#进程控制器pids-1" class="headerlink" title="进程控制器pids"></a>进程控制器<code>pids</code></h5><p>这个控制器的配置文件不会出现在根CGroup目录中。</p>
<ul>
<li><code>pids.max</code>：该CGroup中允许的最大进程数量。默认为<code>max</code>表示不设限制。</li>
<li><code>pids.current</code>：只读文件，当前该CGroups中的进程数。</li>
<li><code>pids.peak</code>：只读文件，该CGroups中的最大进程数。</li>
<li><code>pids.events</code>：只读文件，记录<code>fork()</code>调用失败的次数。</li>
</ul>
<h5 id="大内存页控制器hugetlb"><a href="#大内存页控制器hugetlb" class="headerlink" title="大内存页控制器hugetlb"></a>大内存页控制器<code>hugetlb</code></h5><p>这个控制器的配置文件不会出现在根CGroup目录中。</p>
<ul>
<li><code>hugetlb.页大小.current</code>：当前的HugeTLB用量。</li>
<li><code>hugetlb.页大小.max</code>：设置HugeTLB的最大用量的硬限制。</li>
<li><code>hugetlb.页大小.events</code>：只读文件，包含以下字段：<ul>
<li><code>max</code>：触发HugeTLB最大用量限制的次数。</li>
</ul>
</li>
<li><code>hugetlb.页大小.events.local</code>：只读文件，只属于当前层级的<code>hugetlb.页大小.events</code>记录。</li>
<li><code>hugetlb.页大小.numa_stat</code>：当前CGroup在每个NUMA节点上的用量统计信息。</li>
</ul>
<h4 id="两大规则"><a href="#两大规则" class="headerlink" title="两大规则"></a>两大规则</h4><p>CGroup v2添加了两条最为重要的规则：</p>
<ol>
<li>中间节点无进程规则：<strong>不允许在存在子CGroup的CGroup中直接添加进程，反之，不允许在存在进程的CGroup中创建子CGroup目录</strong>。一个CGroup要么是树的中间节点，要么是叶节点，如果它是中间节点，那么它不应该包含任何进程；如果它是叶节点，那么它不应该有子CGroup。（注意，这条规则有一点点小例外。根CGroup是特殊的，它允许同时存在进程和子节点——这在特定情况下用于维护内核线程。）<ul>
<li>如果使用CGroup v2，那么规则1通常由内核强制执行：只要你向CGroup中添加了一个进程，内核就会确保你无法违反规则（不能创建子CGroup目录）。在CGroup v1中，这条规则不存在，因此也就不会强制执行，尽管遵循这条规则也是件好事。</li>
</ul>
</li>
<li>单一写者规则：每个CGroup只能有一个写者，即<strong>一个</strong>管理它的进程。一个特定的CGroup应当只有一个所有者，并且当它具备所有者时，<strong>这个所有权是专有的</strong>，不应该有任何其他进程同时进行写操作。这条规则确保了各种进程之间不会竞争CGroup控制权。<ul>
<li>规则2在CGroup v1和CGroup v2上都没有强制执行（毕竟这是UNIX，Root用户可以做任何事情），但是如果你无视它，那么会遇到很多麻烦，因为各种进程将不断竞争CGroup的所有权。</li>
</ul>
</li>
</ol>
<p>这两条规则有很多影响，例如，一个推论是：如果你的容器管理器直接尝试在系统的根CGroup中创建和管理CGroup，那么就违反了规则2，因为根CGroup是<strong>由systemd管理</strong>的，因此<strong>其他任何进程都不得操作</strong>。</p>
<p>看来要分析CGroup v2，我们就不得不仔细看看systemd的资源控制机制了：</p>
<h4 id="CGroup-v2与systemd"><a href="#CGroup-v2与systemd" class="headerlink" title="CGroup v2与systemd"></a>CGroup v2与systemd</h4><p>所有的CGroup v2目录节点，实际上都会在systemd处暴露为一个单元，其中，根CGroup目录（即<code>/sys/fs/cgroup</code>这个目录）固定地被暴露为<code>-.slice</code>。</p>
<p>不同类型的管理对象对应着不同类型的单元，而这些单元的名称又对应着CGroup目录下的一个子目录，根CGroup目录下，包含以下单元的CGroup子目录层级结构（我们不在这里分析systemd各种单元的含义）：</p>
<ul>
<li><code>machine.slice/</code>：所有通过<code>systemd-machined.service</code>注册管理的容器的父CGroup节点。（RunC的Rootful容器也使用该CGroup节点，顺带一提。）</li>
<li><code>user.slice/</code>：所有通过<code>systemd-logind.service</code>管理的用户会话的父CGroup节点。<ul>
<li><code>user-$UID.slice/</code>：通过<code>systemd-logind.service</code>管理的指定UID的用户的所有会话的父CGroup节点。<ul>
<li><code>session-$SESSION_ID.scope</code>：叶节点，包含了通过<code>systemd-logind.service</code>创建的指定UID的用户的指定会话的所有进程。</li>
<li><code>user@$UID.service/</code>：所有和用户级systemd实例的单元的父CGroup节点，以及用户级systemd实例本身对应的服务单元。<ul>
<li><code>init.scope</code>：叶节点，用于包含用户级别的systemd实例进程。</li>
<li><code>app.slice</code>：通过用户级systemd实例创建的一般的用户级<code>.service</code>单元的父节点。</li>
<li><code>session.slice</code>：通过用户级systemd实例创建的重要的用户级<code>.service</code>单元的父节点，这类服务单元内需要明确声明<code>Slice=session.slice</code>以加入该CGroup目录下。（“重要的”指：对会话稳定性有重大影响的服务，例如Display Manager、DBus实例等等。）</li>
<li><code>background.slice</code>：通过用户级systemd实例创建的不重要的用户级<code>.service</code>单元的父节点，这类服务单元内需要明确声明<code>Slice=background.slice</code>以加入该CGroup目录下。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>system.slice/</code>：所有通过系统级systemd实例创建的<code>.service</code>、<code>.socket</code>和<code>.mount</code>单元的父节点。</li>
<li><code>init.scope/</code>：叶节点，用于包含系统级别的systemd实例（即PID1）。</li>
</ul>
<p>以上这些目录，都是由systemd创建的，因此如果我们希望进行资源控制，最符合规则2的方式是，告诉systemd对其进行控制。具体来说，是通过这一条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [--user] set-property 单元名 属性=值</span><br></pre></td></tr></table></figure>
<ul>
<li>将单元名设为系统服务单元，对系统服务进行资源控制。</li>
<li>将单元名设为<code>user-$UID.slice</code>，对特定用户进行资源控制。</li>
<li>添加<code>--user</code>选项，将单元名设为用户服务单元，对用户的特定服务进行资源控制。</li>
</ul>
<p>如果我们希望创建一个带有特定CGroup限制的进程，除了手动创建一个用户级服务，一个较为简单的方法是使用<code>systemd-run</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-run --unit=任务名 [--user] [--scope] [-G] [-p 属性=值] [-d|--working-directory=工作目录] [-E &quot;Key=value&quot;] [-r] 执行的命令</span><br></pre></td></tr></table></figure>
<ul>
<li>创建的用户级单元默认会添加到<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/app.slice</code>目录下，如果希望在<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service</code>目录下创建独立的CGroup目录进行管理，添加配置<code>-p Slice=分片名.slice</code>。</li>
<li><code>-p 属性=值</code>：配置Property，在这里进行CGroup相关的限制。</li>
</ul>
<p>通过系统级systemd实例创建一个进程后，我们即可在之前所说的<code>/sys/fs/cgroup/system.slice/</code>目录下找到该<code>.service</code>或是<code>.scope</code>单元对应的CGroup目录。</p>
<p>通过用户级systemd实例创建一个进程后，我们即可在之前所说的<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/app.slice/</code>目录下找到该<code>.service</code>或是<code>.scope</code>单元对应的CGroup目录。</p>
<p>但是这样还是太不方便了，我们能不能摆脱systemd的限制，自己维护一个CGroup目录层级结构呢？答案是可以的。怎么实现呢？这就是通过systemd的委派功能：</p>
<h4 id="委派（Delegation）"><a href="#委派（Delegation）" class="headerlink" title="委派（Delegation）"></a>委派（Delegation）</h4><p>译自<a target="_blank" rel="noopener" href="https://systemd.io/CGROUP_DELEGATION/">Control Group APIs and Delegation</a>。</p>
<p>容器管理器等程序往往会希望直接使用内核API来控制CGroup。只要遵循了适当的委派规则，这是完全可以支持的。委派是CGroup v2创造的一个概念，但之后也移植到了CGroup v1上。</p>
<p>委派意味着CGroup树的某些部分可能由不同的进程管理。只要清楚哪个进程管理树的哪一部分，每个进程都可以在其管理范围内随意操作。只有子树可以被委派（尽管任何决定请求子树的进程都可以进一步将子子树委派给其他进程，只要它们愿意的话）。</p>
<p>委派发生在特定的CGroup节点上：在systemd中，有一个<code>Delegate=</code>属性，可以为<code>.service</code>或<code>.scope</code>单元设置。如果这样做，这个节点就会成为systemd的CGroup管理权的切换点：单元本身由systemd管理，即它的所有属性都是由systemd负责的，然而该单元的程序可以自由地在其CGroup目录中创建&#x2F;删除子CGroup，这些子CGroup随后成为该程序的专有财产，systemd不会处理它们——换句话说，所有这些子CGroup的属性都可以由这个程序自由操作。</p>
<p>启用<code>Delegate=</code>属性会有以下几个影响：</p>
<ol>
<li>systemd绝不会再干预该CGroup目录下的子树，它不会修改子树中任何CGroup的属性，也不会在子树中创建任何目录。</li>
<li>如果该单元中指定了<code>User=</code>属性，那么该子树会被<code>chown()</code>至目标用户，以便他可以正确地创建目录。请注意，这仅在CGroup v2或是systemd的私有控制器目录下生效，它不会转移CGroup v1的其他控制器目录的所有权。</li>
<li>所有systemd安装的BPF IP过滤器程序都会加上<code>BPF_F_ALLOW_MULTI</code>，以允许用户程序可以安装附加的BPF程序。</li>
</ol>
<p>在单元文件中，<code>Delegate=</code>属性一般采用布尔值。不过，从v236版本开始，它也可以接受空格分隔控制器名称。如果这样设置，那么systemd会将列出的控制器请求委派。不过需要注意，这只是一个请求。根据情况的不同，可能会导致实际上委派给服务的控制器数量不一致（例如，某些控制器在当前的内核上不可用或者被禁用）。如果设为布尔真值，那么所有可用的控制器都将被委派。</p>
<p>让我们强调一点：委派只在<code>.scope</code>和<code>.service</code>单元上可用。它不适用于<code>.slice</code>单元。为什么？因为切片单元是我们CGroup树的中间节点，我们可以自由地将<code>.service</code>和<code>.scope</code>单元附加到它们上。如果我们允许在<code>.slice</code>单元上进行委派，那么这将意味着systemd和用户自己的进程都有权在切片单元下创建&#x2F;删除CGroup，这与单一写者规则相冲突。</p>
<p>因此，如果用户希望进行原始CGroup内核级别访问，需要专门分配一个<code>.service</code>或<code>.scope</code>单元（或者使用现成的为自己的程序编写的服务单元），并为它开启委派。</p>
<p>Service Manager会在启用委派的CGroup目录上设置<code>user.delegate</code>扩展属性（通过<code>getxattr(2)</code>及相关调用），并将其值设置为字符1（这在未启用委派的CGroup上不存在）。这可以被服务程序用来确定CGroup子树是否已经委派给它们。请注意，这只在5.6及更高版本的Linux内核以及systemd &gt;&#x3D; 251的版本中支持。</p>
<ul>
<li>警告：如果你为服务开启了委派，并且该服务设置了<code>ExecStartPost=</code>、<code>ExecReload=</code>、<code>ExecStop=</code>或<code>ExecStopPost=</code>，那么这些命令将在服务CGroup的<code>.control/</code>子CGroup中执行。这是必要的，因为通过开启委派，systemd必须假定现在你的服务单元的CGroup是一个中间CGroup，这意味着它不会直接包含任何进程。因此，如果你的服务设置了这四个设置中的任何一个，你必须意识到可能会出现由Service Manager管理的<code>.control/</code>子CGroup。这也意味着你的服务代码应该在使用<code>systemd-notify</code>通知Service Manager启动就绪时已经把自己移动到了CGroup树的更深层次，以便在Service Manager可能开始执行<code>ExecStartPost=</code>时，服务的主CGroup肯定是一个中间节点。从systemd 254版本开始，你也可以使用<code>DelegateSubgroup=</code>让Service Manager立即将你的初始服务进程放入一个子组中。</li>
<li>另外注意，如果你打算使用“线程化”CGroup——在Linux 4.14中添加的特性——那么你应该在为其开启委派的主CGroup的后两级进行。为什么？首先，第一级目录是为了确保systemd可以正确地创建<code>.control</code>子组，如上所述。但是这个子组不能是线程化的，因为这将意味着<code>.control</code>也必须是线程化的——这是线程化CGroup的要求：要么CGroup及其所有同级CGroup都是线程化的，要么都不是——但systemd显然期望<code>.control</code>子组是一个常规CGroup。因此，你必须在它之下嵌套创建第二个CGroup，然后这个CGroup才可以是线程化的。</li>
</ul>
<p>实际上，用户级systemd实例的服务单元本身就带有<code>Delegate=</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /lib/systemd/system/user@.service</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Delegate=pids memory cpu</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这意味着<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/</code>目录下的<code>pids</code>、<code>memory</code>和<code>cpu</code>控制器是委派给用户级systemd实例进行管理的。正因如此，用户级systemd实例才能在用户的<code>.service</code>或<code>.scope</code>单元中存在<code>Slice=</code>属性时，为其在<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/</code>目录下创建合适的<code>.slice</code>子目录。</p>
<p>举例来说，Docker和Podman的底层工具RunC在以Rootless模式运行时，它会将容器进程向systemd注册为<code>.scope</code>单元，并且配置<code>Slice=user.slice</code>，这样，用户级systemd实例就会创建<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/user.slice/</code>目录，并将容器的<code>.scope</code>单元并统一安置在该目录下。</p>
<p><img src="/images/podman-user-slice.png" alt="podman-user-slice.png"></p>
<h4 id="三种场景"><a href="#三种场景" class="headerlink" title="三种场景"></a>三种场景</h4><p>我们假定你是一个容器管理器的开发者，正在考虑怎么处理CGroup，以使其在使用systemd的系统上运行。那么你有三种选择：</p>
<ol>
<li>接受集成。对于这个选项，你可以将每个容器注册为一个systemd的<code>.service</code>单元（即让systemd负责调用执行器的二进制程序）或一个systemd的<code>.scope</code>单元（即由你的管理器负责执行二进制程序，但之后向systemd注册）。在这种模式下，管理员可以使用systemd的资源管理和内省命令对这些容器进行管理。通过为这些作用域或服务启用<code>Delegate=</code>，你可以在容器中运行依赖CGroup的程序，例如嵌套的systemd实例。这个选项又有两种子选项：<ol>
<li>你可以通过直接通过D-Bus与systemd交流来临时地注册<code>.service</code>或<code>.scope</code>单元。在这种情况下，systemd将只负责管理单元，不做其他事情。</li>
<li>你可以通过<code>systemd-machined.service</code>（也是通过 D-Bus）注册<code>.service</code>或<code>.scope</code>单元。这个守护进程基本上只是上一种选项中相同操作的代理。这样做的主要好处是：你可以让系统知道你注册的是容器，这将启用某些额外的集成功能。例如，如果容器内运行了systemd，<code>journalctl -M</code>可以用来直接查看容器的日志，或者<code>systemctl -M</code>可以用来直接在容器内部执行systemd操作。此外，像<code>ps</code>这样的工具可以显示一个进程属于哪个容器（试试执行<code>ps -eo pid,comm,machine</code>），甚至<code>gnome-system-monitor</code>也存在支持。</li>
</ol>
</li>
<li>“孤岛”选项。如果你只关心你自己的CGroup树，并且希望尽可能少与systemd打交道，对与系统其余部分的集成完全不感兴趣，那么这是一个合适的选项。对此，你所要做的就是为你的主守护进程启用<code>Delegate=</code>。然后找出systemd将你的守护进程放在哪个CGroup中：然后，你就可以在其下自由创建子CGroup。但不要忘记中间节点无进程的规则：在你的子CGroup中启动进程之前，你必须将你的主守护进程移出该CGroup（并移入该CGroup的一个子CGroup）。</li>
<li>“领地”选项。你坚持要保留你的守护进程所在的CGroup位置，并且不在其单元上打开委派。那么，当你启动第一个被管理的进程（例如容器）时，你需要向systemd注册一个新的<code>.scope</code>单元，并且该<code>.scope</code>单元需要启用<code>Delegate=</code>，并将该进程移入该<code>.scope</code>单元；随后创建的所有被管理的进程也都应该移动到这个<code>.scope</code>单元中。这样处理后，从systemd的角度来看，只有两个单元：你的管理进程的<code>.service</code>单元和包含所有被管理的进程的大<code>.scope</code>单元。</li>
</ol>
<p>顺便说一句，如果你出于任何原因认为：“我讨厌D-Bus，我永远不会调用任何D-Bus API，谢谢再见。”，那么1号和3号选项就都不可用了，因为它们需要通过D-Bus让你的程序与systemd通信。但是在这种情况下，你仍然有2号选项，因为你可以简单地在<code>.service</code>单元文件中设置<code>Delegate=</code>，然后你就拥有了自己的CGroup子树。事实上，2号选项是唯一允许你完全忽略systemd存在的选项：你只需要遵循单一写者规则，即只使用你启动时所在的CGroup节点及其下面的所有内容。</p>
<ul>
<li>话虽如此，如果你真的有“那么”不喜欢D-Bus和systemd，也许更好的办法是转变态度，拓宽一下视野。谢谢。</li>
</ul>
<h4 id="控制器支持"><a href="#控制器支持" class="headerlink" title="控制器支持"></a>控制器支持</h4><p>systemd支持多种资源控制器（但不是全部）。具体来说，支持的有：</p>
<ul>
<li>CGroup v1：<code>cpu</code>、<code>cpuacct</code>、<code>blkio</code>、<code>memory</code>、<code>devices</code>、<code>pids</code>。</li>
<li>CGroup v2：<code>cpu</code>、<code>io</code>、<code>memory</code>、<code>pids</code>。</li>
</ul>
<p>我们的目标是原生支持所有添加到内核的CGroup v2控制器。然而，对于CGroup v1，我们将不再添加对任何其他控制器的支持。这意味着systemd目前不支持，而且永远也不会支持在CGroup v1上管理以下控制器：<code>freezer</code>、<code>cpuset</code>、<code>net_cls</code>、<code>perf_event</code>、<code>net_prio</code>、<code>hugetlb</code>。</p>
<ul>
<li>为什么不支持？要么是它们的API语义或实现并不真正可用，要么是它们很明显在CGroup v2上没有未来，我们不会为明显没有未来的东西添加新代码。</li>
</ul>
<p>实际上这意味着所有这些未支持的CGroup v1控制器都可以被直接使用：systemd不会管理它们，因此也不会负责将它们委派给你的程序（当然，systemd仍然会挂载它们的层级结构，不过仅仅是因为它会自动挂载内核中发现的所有可用的控制器）。如果你决定使用它们，没问题，但是systemd不会给你提供任何帮助（当然，也不会干涉你）。你可能会希望为其他租户中保持在其他控制器中一致的CGroup层级结构，但这是你与其他租户之间的事情，systemd并不关心。在这些不受支持的控制器中复制CGroup层级结构意味着需要在它们中保持完整的CGroup路径一致，因此也包括<code>.slice</code>目录，否则这些层级结构最终会变得正交，这并不是我们想要的。</p>
<p>还有一点：systemd会在它负责管理的层级结构中清理你的痕迹：如果你的进程停止，那么它的CGroup目录也会被移除。你可以得到这样的保证：每当你的<code>.service</code>或<code>.scope</code>单元启动时，你都会得到一个初始化的CGroup子树。然而，在systemd不进行管理的层级结构中情况并非如此。这意味着你的程序必须准备好处理它们残留的——之前运行留下的——CGroup目录，并且要特别小心——因为它们可能仍然包含着不再有效的设置。</p>
<p>请注意，这里有一个特殊的不对称性：如果你的systemd版本在CGroup v1上不支持某个特定的控制器，你仍然可以通过直接操作其层级结构并根据需要复制CGroup树来使用它进行委派（如上所建议的）。然而，在CGroup v2上情况不同：单独挂载的层级结构不可用，<strong>委派总是必须通过systemd本身进行</strong>。这意味着：当你更新内核并且添加了一个新的、迄今为止未见过的控制器，如果你想使用它进行委派，那么你也需要更新systemd到一个能够理解它的版本。</p>
<h4 id="作为容器载荷的systemd"><a href="#作为容器载荷的systemd" class="headerlink" title="作为容器载荷的systemd"></a>作为容器载荷的systemd</h4><p>systemd完全可以作为容器载荷的 PID 1 运行。但是请注意，systemd无条件地需要对CGroup树的写权限，因此你需要将一个子树委派给它。除此之外，你不需要进行太多特别的操作：只需在委派的CGroup子树的根节点调用systemd作为 PID 1，它会自己弄清楚其他的情况：它会确定它正在运行的CGroup子树并占有它。systemd不会干涉它被调用的子树之外的任何CGroup。因此，使用<code>CLONE_NEWCGROUP</code>是可选的（但是，这么做当然是明智的）。</p>
<p>但这里有一个特别的不对称性需要注意：systemd会尝试完全占有你传递给它的根CGroup目录，也就是说，它不仅会在其下创建&#x2F;删除子CGroup，还会尝试管理这个根CGroup自己的属性。另一方面，如上所述，当将CGroup树委派给其他进程时，它只能传递创建&#x2F;删除子CGroup的权限，但是会保持管理委派的CGroup树的顶级属性。换句话说：systemd在接受被委派的CGroup树时是贪婪的，同时在将它们委派给其他进程时也是贪婪的：它会坚持在两种情况下管理这些特定CGroup的属性。因此，一个本身是宿主systemd的载荷并希望运行自己的systemd作为其容器载荷的容器管理器，需要在层级结构之间插入一个额外的层级，以便宿主上的systemd和容器中的systemd不会为属性而竞争。话虽如此，由于中间节点不得包含进程的规则，你可能无论如何都不得不这样做，请参见下文。</p>
<p>当systemd作为容器载荷运行时，它会使用它具有写权限的所有层级结构。对于传统模式，你需要至少提供<code>/sys/fs/cgroup/systemd/</code>，所有其他层级结构都是可选的。对于混合模式，你需要添加<code>/sys/fs/cgroup/unified/</code>。最后，对于统一模式，你只需要提供<code>/sys/fs/cgroup/</code>本身。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在CGroup v2上开发容器管理器时，应该做的事：</p>
<ol>
<li>如果你选择了上面的实现选项1.1或1.2，那么你的每个容器都将拥有自己的systemd单元，因此可能在下一级有子CGroup。通常在该单元中运行的第一个进程将是某种类型的执行器程序（Executor），它会派生出容器的载荷进程。在这种情况下，<strong>请不要忘记两级委派</strong>：首先，systemd将一个CGroup子树委派给你的执行器进程。然后你的执行器应该将子树进一步委派给容器载荷进程——哦，对了，由于中间节点不得包含进程的规则，你的执行器也需要将自己迁移到其被委派的CGroup的子CGroup中。因此，你可能会想采取双管齐下的方法：在你启动的CGroup下面，你可能想要创建一个名为<code>supervisor/</code>的子CGroup，你的容器管理器在其中运行，然后为每个容器创建一个该CGroup的同级CGroup，可能称为<code>payload-xyz/</code>。（可以参考<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/main/docs/cgroup-v2.md">RunC</a>）</li>
<li>不要忘记你创建的CGroup必须使用适合作为UNIX文件名的名称，并且它们位于与各种内核属性文件相同的命名空间中。因此，如果你希望允许用户任意命名，那么你可能需要对一些名称进行转义（例如，你应该不会希望仅仅因为用户创建了一个名为<code>tasks</code>的容器，就创建一个名为<code>tasks</code>的CGroup，因为<code>tasks</code>毕竟是CGroup v1中的一个魔法属性，你的<code>mkdir()</code>将会因为发生<code>EEXIST</code>而失败。在systemd中，我们通过为可能与内核属性名称冲突的名称添加下划线前缀来进行转义。你可能也会想这样做，但这归根结底取决于你的决定。只是要做好，而且要小心。</li>
</ol>
<p>不应该做的事情：</p>
<ol>
<li>永远不要在systemd管理的任意CGroup下创建你自己的CGroup，即你没有在其中设置<code>Delegate=</code>的CGroup。特别是：<strong>不要在根CGroup下创建你自己的CGroup</strong>，那是systemd所有的。如果忽视这一点，你将影响systemd的工作，systemd也会影响你的工作。获取自己的委派子树，你可以在那里创建任意多的CGroup。<strong>认真地说，如果你尝试直接在CGroup根目录中创建CGroup，那么你所做的一切都只是自找麻烦</strong>。</li>
<li>不要尝试在切片单元中设置<code>Delegate=</code>，<strong>特别是不要在<code>-.slice</code>中设置</strong>。这种行为不受支持，而且将产生错误。</li>
<li>永远不要写入systemd创建的任何CGroup的属性，那是systemd的私有信息。你可以随意操纵你在自己委派的子树中创建的CGroup的属性，但是<strong>systemd自己的CGroup树对你来说是禁区</strong>。不过，你可以随意读取这些属性，这是完全可以的。</li>
<li>当委派子树给运行systemd的容器载荷，且未使用<code>CLONE_NEWCGROUP</code>时，不要只把宿主的CGroup树中的这个子树绑定挂载到容器中。CGroup API中有一个部分是<code>/proc/$PID/cgroup</code>，它会报告每个进程的CGroup路径，因此<code>/sys/fs/cgroup/</code>下的任何路径都需要与负载进程的<code>/proc/$PID/cgroup</code>报告的内容相匹配。你应该做的是将CGroup树的上层部分挂载为只读（甚至可以用<code>tmpfs</code>替换中间部分，但要小心——不能破坏上面讨论的<code>statfs()</code>检测逻辑），只要委派子树的路径仍然可以按原样访问。</li>
<li>目前，将<code>.slice</code>&#x2F;<code>.scope</code>&#x2F;<code>.service</code>单元的命名与它们的CGroup路径之间进行映射的算法没有被视为systemd的公共API，并且可能在未来的版本中发生变化。这意味着：最好避免在你的程序中实现将CGroup路径转换为<code>.slice</code>&#x2F;<code>.scope</code>&#x2F;<code>.service</code>单元名称的本地逻辑，反之亦然——这可能在未来会被破坏。相反，请使用适当的D-Bus API调用，以便systemd为你进行转换。<ul>
<li>具体来说：每个单元对象都有一个<code>ControlGroup</code>属性来获取单元的CGroup。<code>GetUnitByControlGroup()</code>方法可用于获取CGroup的单元。</li>
</ul>
</li>
<li>在将CGroup v1控制器委派给权限较低的容器之前要三思。这是不安全的，这么做基本上等同于允许你的容器冻结宿主系统，甚至于更糟。委派是CGroup v2的强项，在CGroup v2中，将委派边界视为权限边界是安全的。</li>
</ol>
<h4 id="附：打破规则2"><a href="#附：打破规则2" class="headerlink" title="附：打破规则2"></a>附：打破规则2</h4><p>假定我们无视规则2，希望直接手动创建一个CGroup目录对我们在会话中创建的某个进程进行控制，这个进程是由我们手动创建的，因此它应当位于<code>/sys/fs/cgroup/user.slice/user-$UID.slice/session-$SESSION_ID.scope/</code>目录下，那么CGroup目录应当建在哪里呢？</p>
<p>肯定不能是<code>/sys/fs/cgroup/user.slice/user-$UID.slice/session-$SESSION_ID.scope/</code>目录下，因为根据规则1，这个CGroup目录中包含了进程，因此不能包含子CGroup目录。那么就只剩下<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service</code>目录了。</p>
<p>我们可以在该目录下创建一个<code>.slice</code>后缀的目录对<code>session-$SESSION_ID.scope</code>下的进程进行CGroup控制。只要这个进程是长时间运行的，那么这个会话的<code>.scope</code>单元<code>session-$SESSION_ID.scope</code>就会随着这个进程的存在而存在，而<code>user@$UID.service</code>也会随着这个<code>.scope</code>单元的存在而存在。</p>
<p>当该进程终止时，这个会话的<code>.scope</code>单元<code>session-$SESSION_ID.scope</code>就会随之销毁，如果这是该用户的最后一个会话，那么<code>user@$UID.service</code>也会随之销毁。</p>
<p>当然，这种方式打破了规则2，因为<code>/sys/fs/cgroup/user.slice/user-$UID.slice/user@$UID.service/</code>目录实际上是由用户级systemd实例管理的，符合规则的做法应该是如之前所述，创建用户级<code>.scope</code>或<code>.service</code>单元封装运行，并通过在用户级单元中添加<code>Slice=</code>属性请求用户级systemd实例创建独立的<code>.slice</code>目录。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/30/MKOSI%E7%AC%94%E8%AE%B0/" rel="prev" title="MKOSI笔记">
                  <i class="fa fa-angle-left"></i> MKOSI笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/23/10%E5%B9%B4%E5%90%8E%E7%9A%84systemd/" rel="next" title="10年后的systemd">
                  10年后的systemd <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Molten_Armor</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
