<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.icku.eu.org","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文是我在制作自己的USR不可变系统时的一些记录。你可以访问MoltenArmor&#x2F;not-so-immutable-os查看我的系统源码。">
<meta property="og:type" content="article">
<meta property="og:title" content="一起制作USR不可变系统">
<meta property="og:url" content="https://blog.icku.eu.org/2024/12/21/%E4%B8%80%E8%B5%B7%E5%88%B6%E4%BD%9CUSR%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="MA Blog">
<meta property="og:description" content="本文是我在制作自己的USR不可变系统时的一些记录。你可以访问MoltenArmor&#x2F;not-so-immutable-os查看我的系统源码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os1.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os2.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os3.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os4.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os5.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os6.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os7.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os8.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os9.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os10.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os11.png">
<meta property="og:image" content="https://blog.icku.eu.org/images/not-so-immutable-os12.png">
<meta property="article:published_time" content="2024-12-21T08:36:41.000Z">
<meta property="article:modified_time" content="2025-10-01T14:12:53.628Z">
<meta property="article:author" content="Molten_Armor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.icku.eu.org/images/not-so-immutable-os1.png">


<link rel="canonical" href="https://blog.icku.eu.org/2024/12/21/%E4%B8%80%E8%B5%B7%E5%88%B6%E4%BD%9CUSR%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B3%BB%E7%BB%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.icku.eu.org/2024/12/21/%E4%B8%80%E8%B5%B7%E5%88%B6%E4%BD%9CUSR%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B3%BB%E7%BB%9F/","path":"2024/12/21/一起制作USR不可变系统/","title":"一起制作USR不可变系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>一起制作USR不可变系统 | MA Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MA Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFUSR%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是USR不可变系统？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么要这么做？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">整体设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.</span> <span class="nav-text">分区设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%95%9C%E5%83%8F"><span class="nav-number">6.</span> <span class="nav-text">扩展镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89%E5%8F%AF%E5%86%99%E7%9A%84-etc"><span class="nav-number">6.0.1.</span> <span class="nav-text">（已废弃）可写的&#x2F;etc&#x2F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%A3%E9%94%81%E7%9A%84-etc"><span class="nav-number">6.0.2.</span> <span class="nav-text">动态解锁的&#x2F;etc&#x2F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-number">6.0.3.</span> <span class="nav-text">测试环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">6.0.4.</span> <span class="nav-text">保留软件包元数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E9%87%8A%E6%94%BE"><span class="nav-number">7.</span> <span class="nav-text">系统文件释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0"><span class="nav-number">8.</span> <span class="nav-text">系统更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%89%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">汉化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E8%AE%B0"><span class="nav-number">10.</span> <span class="nav-text">杂记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8Dregulatory-db"><span class="nav-number">10.1.</span> <span class="nav-text">修复regulatory.db</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%8F%A3%E5%91%B3"><span class="nav-number">11.</span> <span class="nav-text">镜像口味</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Live%E7%B3%BB%E7%BB%9F"><span class="nav-number">12.</span> <span class="nav-text">Live系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">Debug模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">14.</span> <span class="nav-text">STM服务端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">救援模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Initrd%E6%96%AD%E7%82%B9"><span class="nav-number">16.</span> <span class="nav-text">Initrd断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E5%8E%82%E5%8C%96"><span class="nav-number">17.</span> <span class="nav-text">出厂化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%88%AA%E5%9B%BE"><span class="nav-number">18.</span> <span class="nav-text">一些截图</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Molten_Armor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.icku.eu.org/2024/12/21/%E4%B8%80%E8%B5%B7%E5%88%B6%E4%BD%9CUSR%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Molten_Armor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MA Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="一起制作USR不可变系统 | MA Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一起制作USR不可变系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-21 16:36:41" itemprop="dateCreated datePublished" datetime="2024-12-21T16:36:41+08:00">2024-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-01 22:12:53" itemprop="dateModified" datetime="2025-10-01T22:12:53+08:00">2025-10-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文是我在制作自己的USR不可变系统时的一些记录。你可以访问<a target="_blank" rel="noopener" href="https://github.com/MoltenArmor/not-so-immutable-os">MoltenArmor&#x2F;not-so-immutable-os</a>查看我的系统源码。</p>
<span id="more"></span>

<h2 id="什么是USR不可变系统？"><a href="#什么是USR不可变系统？" class="headerlink" title="什么是USR不可变系统？"></a>什么是USR不可变系统？</h2><p>顾名思义，就是围绕<code>/usr</code>文件系统不可变这一核心设计的操作系统。</p>
<h2 id="为什么要这么做？"><a href="#为什么要这么做？" class="headerlink" title="为什么要这么做？"></a>为什么要这么做？</h2><p>看到标题，大部分人肯定会首先想到这一问题：为什么要这么干？这有什么意义？但是先等等，我们先不说“为什么”，让我们先来看现在的Linux发行版在管理时的困境。</p>
<p>设想你希望在VM中使用一个Debian，应该怎么做呢？你首先要去官方网站下载一个Debian installer ISO镜像，然后需要将镜像接入VM，在其中运行Debian installer程序，在安装完成后，你还需要修改系统配置，需要安装自己需要的软件包，需要调整系统服务的运行状态。</p>
<p>在日后的管理中，你还需要反复地使用<code>apt</code>安装软件包，这些软件包都有着复杂的<code>postinst</code>脚本和相互依赖关系，如果稍有不慎破坏了依赖链，你的整个系统可能都会受到影响。除此之外，如果之后你移除了软件包，那么包管理器并不会移除<code>/etc/</code>下你编写的配置文件，这些文件日积月累会变成不计其数的脏数据。而且，在系统更新后，<code>/etc/</code>下还会出现两份，甚至更多的旧版本配置归档（<code>.dpkg-old</code>），更是让情况火上浇油。尤其是在日后系统有大型更新，涉及到大量软件包变化的情况下，除了重新安装，似乎并没有什么更好的办法了。</p>
<p>这套模式已经出现并且被使用了数十年，但是这并不代表它没有问题，恰恰相反，它有很多毛病。</p>
<p>为什么要使用Installer程序呢？很早之前就有人使用块设备镜像的方式进行系统备份了，那么它既然可以用于备份，难道不可以用于安装吗？现在不就有这样的系统构建工具<code>mkosi</code>吗？我们只要构建出一个磁盘镜像，直接烧录（二进制写入）到磁盘中，不就得到了一个完整的操作系统吗？</p>
<p>为什么要我们手动进行配置呢？systemd不是已经提供了<code>systemd-tmpfiles</code>、<code>systemd-sysusers</code>、<code>systemd-firstboot</code>等组件，来让系统在启动时达到合适的状态吗？我们不仅不需要手动修改任何文件，而且甚至不需要编写复杂的Shell脚本，只需要提供合适的这些systemd组件的配置，就可以让系统在启动时就达到我们期望的状态。而所有这些配置文件都可以被封装在<code>/usr</code>中，在第一次启动时被systemd读取。没有听懂吗？换句话说：只要我们在<code>/usr</code>中封装好这些组件的配置和一些必要的文件，那么<code>/</code>下的其他层次结构，例如<code>/etc/</code>，完全可以在我们第一次启动时，从<code>/usr</code>中被“释放”或者说“生成”出来。</p>
<ul>
<li>同时，这也意味着，系统存在“出厂状态”这一概念了：其他层次结构尚未从<code>/usr</code>中被释放出来的状态。如此一来，我们就完全可以在任何时候对操作系统进行“恢复出厂状态”了。</li>
</ul>
<p>为什么我们要用包管理器安装软件包呢？系统之所以会变得复杂，归根结底是因为我们“能”让它变得复杂，在系统层面缺乏强硬的限制。我们已经知道，通过Usr-merge计划和上一段提到的“生成”逻辑，系统的所有关键资源已经被保存在了<code>/usr</code>。因此我们完全可以将系统理解为<code>/usr</code>下所有资源的集合——那么，系统的版本，不就是<code>/usr</code>的版本吗？那么，我们不就可以把整个系统以一份<code>/usr</code>镜像的形式发布了吗？那么，我们不就可以通过统一<code>/usr</code>（使其不可变）的方式，来确保全世界所有用户的系统环境都一致了吗？</p>
<ul>
<li>同时，这也意味着，我们在更新时可以采用A&#x2F;B更新的方式，即：在一个地方创建新版本的<code>/usr</code>文件系统，然后通过某种方式让系统在启动时加载这个新版本的<code>/usr</code>文件系统（而不是旧版本的）。这同样有systemd提供的组件：<code>systemd-sysupdate</code>。</li>
<li>你可能会疑惑：不能在<code>/usr</code>上使用包管理器，我怎么安装应用程序呢？这样的可扩展性不是太差劲了吗？实际上是存在解决方案的：设想一下，如果<code>/usr</code>文件系统的内容已经是确定的，那么安装软件包这个行为的含义，不就是在<code>/usr</code>中添加新的文件吗？那么，我们完全可以获取出安装你所需要的软件包时，相对于<code>/usr</code>文件系统产生的增量的文件，然后构建出一个包含该软件包的镜像，接着通过Linux内核提供的Overlayfs功能，挂载到<code>/usr</code>，不就相当于安装了这些软件包吗？这就是<code>systemd-sysext</code>和<code>systemd-confext</code>的功能。</li>
</ul>
<p>这就是<code>/usr</code>不可变的意义所在，它通过新的结构性设计解决了传统Linux发行版随时间变化不可避免地变得复杂和混乱的问题。回顾前面提到的内容，我们不难看出，这一设计的核心理念就是“操作系统即代码”（System As Code）。通过精心编写的代码，使得我们可以构建出自定义的、可更新的、可共享的操作系统。</p>
<p>更多的细节，请参考<a href="https://blog.icku.eu.org/2024/11/17/USR%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EParticleOS/">ParticleOS</a>。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>毫无疑问使用<code>mkosi</code>，事实上这就是systemd在提出该设想时推荐的构建工具，<code>mkosi</code>同时可以构建磁盘镜像、Initrd、UKI镜像和Sysext系统扩展镜像。</p>
<p><code>mkosi</code>目前正在紧张地进行着开发，所以我建议你使用开发中的版本，你可以使用Pipx安装，也可以使用其他任何你喜欢的工具安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install git+https://github.com/systemd/mkosi.git</span><br></pre></td></tr></table></figure>

<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>A&#x2F;B更新模式依赖“封装内核命令行参数”的功能（我们之后会提到原因），因此我们需要使用UKI，这也是<code>mkosi</code>的默认策略，所以我们不需要特别配置。</p>
<p>我比较懒，所以不希望使用安全启动（Secure Boot），因此，在<code>mkosi.conf</code>中禁用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Validation]</span><br><span class="line">SecureBoot=no</span><br><span class="line">SignExpectedPcr=no</span><br><span class="line">SecureBootAutoEnroll=no</span><br></pre></td></tr></table></figure>

<p>我希望能生成一个可以做VM的磁盘镜像，因此将“将产品分离为独立的分区镜像”这一配置我们禁用，以导出单个<code>.raw</code>磁盘镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Output]</span><br><span class="line">SplitArtifacts=no</span><br><span class="line">Format=disk</span><br></pre></td></tr></table></figure>

<h2 id="分区设计"><a href="#分区设计" class="headerlink" title="分区设计"></a>分区设计</h2><p>如前所述，在最基本的情况下，我们期望一个独立的、不可变的<code>/usr</code>文件系统，以及一个可写的<code>/</code>。此外，我们还希望对<code>/usr</code>进行A&#x2F;B更新。那么毫无疑问，我们的系统中就应该存在：</p>
<ol>
<li>EFI System Partition，用于保存引导需要的EFI PE程序</li>
<li>版本A的USR分区。</li>
<li>版本B的USR分区。</li>
<li>Swap分区</li>
<li>根分区</li>
</ol>
<p>这些分区都是通过<code>systemd-repart</code>进行创建的，但是，创建的时机有所不同，可以是在构建时创建的，也可以是在系统启动时创建。具体来说，为了确保构建好的产品最小化，我们会在构建时创建尽可能少的分区，其他分区在启动时按照环境创建。在以上列表中，只有1（用于在构建时保存引导必备的EFI PE程序）、2（用于在构建时保存所有的资源文件）是必要的，因此应当保存在<code>mkosi.repart/</code>，在构建时读取。其它的只需要保存在<code>mkosi.images/base/mkosi.extra/usr/lib/repart.d/</code>目录下，在系统启动时读取。</p>
<blockquote>
<p>systemd在基本的根文件系统层次结构（即<code>/bin -&gt; /usr/bin</code>、<code>/lib -&gt; /usr/lib</code>等）不存在时，会自动创建。</p>
</blockquote>
<p>我们之前已经提到过了A&#x2F;B更新的思路，但是这具体是怎么实现的呢？我们知道，GPT分区表是支持保存分区PARTLABEL，并通过PARTLABEL定位分区的。因此，我们完全可以将版本号作为分区的PARTLABEL，以此确定分区版本，同时，我们将<code>root=PARTLABEL=XXX</code>的内核命令行参数封装到版本对应的UKI中，这样，系统在启动时，只要使用某个版本的UKI，那么启动时，就一定会使用对应版本的<code>/usr</code>分区：</p>
<p><code>mkosi.conf</code>中需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Content]</span><br><span class="line">KernelCommandLine=rw mount.usr=PARTLABEL=%i_%v</span><br></pre></td></tr></table></figure>

<p><code>mkosi.images/base/mkosi.extra/usr/lib/repart.d/usr-verA.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Partition]</span><br><span class="line">Type=usr</span><br><span class="line">Label=%M_%A    # 初始版本号</span><br><span class="line">SizeMinBytes=5G</span><br><span class="line">SizeMaxBytes=20G</span><br><span class="line">Weight=2000</span><br></pre></td></tr></table></figure>

<p><code>mkosi.images/base/mkosi.extra/usr/lib/repart.d/usr-verA.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Partition]</span><br><span class="line">Type=usr</span><br><span class="line">Label=_empty    # 该分区初始情况下不存储任何版本的USR数据，所以初始情况下Label设为_empty就好</span><br><span class="line">SizeMinBytes=5G</span><br><span class="line">SizeMaxBytes=20G</span><br><span class="line">Weight=2000</span><br></pre></td></tr></table></figure>

<h2 id="扩展镜像"><a href="#扩展镜像" class="headerlink" title="扩展镜像"></a>扩展镜像</h2><p>为了日后的扩展性，我们需要构建扩展镜像。</p>
<p>如前所述，要构建扩展镜像，我们首先需要确定获取增量文件的基础镜像，也就是最小化的<code>/usr</code>，然后再获取相对于该镜像的增量，构建另一个Sysext镜像，这意味着我们需要用到<code>mkosi</code>的子镜像功能<code>mkosi.images/</code>。</p>
<p>我们将基础系统镜像保存为<code>mkosi.images/base/</code>，这里包含了最小化、可引导的系统构建配置。同时，我们将这样一个镜像的构建格式设为文件系统目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Build]</span><br><span class="line">Format=directory</span><br></pre></td></tr></table></figure>
<p>这样，在构建时，该镜像就会被构建为<code>mkosi.output/base/</code>目录树，我们就可以通过将其设为之后希望构建的Sysext镜像的<code>BaseTrees=</code>来获取增量了，例如我们的<code>mkosi.images/incus/mkosi.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Config]</span><br><span class="line"># 需要依赖Base镜像</span><br><span class="line">Dependencies=base</span><br><span class="line"></span><br><span class="line">[Output]</span><br><span class="line">Format=sysext</span><br><span class="line">Overlay=yes    # 该配置启用增量获取</span><br><span class="line"></span><br><span class="line">[Content]</span><br><span class="line">Bootable=no    # 该镜像是扩展镜像，不需要可引导</span><br><span class="line">BaseTrees=%O/base    # 获取增量的相对目录树</span><br><span class="line">Packages=...    # 安装的软件包</span><br></pre></td></tr></table></figure>

<p>在使用时，我们只需要先执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importctl import-raw --class=sysext xxx.raw</span><br></pre></td></tr></table></figure>
<p>倒入扩展镜像，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-sysext merge</span><br></pre></td></tr></table></figure>
<p>即可接入扩展镜像。</p>
<p>值得注意的是，<code>systemd-sysext</code>在接入扩展镜像后，并不会触发执行<code>systemd-tmpfiles</code>、<code>systemd-sysusers</code>和<code>systemd-update-done.service</code>，因此，你需要手动执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemd-tmpfiles --create</span><br><span class="line"></span><br><span class="line">systemd-sysusers</span><br><span class="line"></span><br><span class="line">cp -rpn /usr/share/factory/ /</span><br></pre></td></tr></table></figure>

<p>此外，在系统初始化时，<code>systemd-sysext</code>接入的镜像中的服务并不会被启动，因此你需要额外在启动后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --no-block default</span><br></pre></td></tr></table></figure>
<p>你可以将这条命令写入<code>/etc/rc.local</code>，以确保在系统进入默认Target时自动执行。</p>
<p>相似的，对于包含了<code>/etc/</code>目录下的配置文件的软件包，我们还需要构建一个Confext镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Config]</span><br><span class="line"># 需要依赖Base镜像</span><br><span class="line">Dependencies=base</span><br><span class="line"></span><br><span class="line">[Output]</span><br><span class="line">Format=confext</span><br><span class="line">Overlay=yes    # 该配置启用增量获取</span><br><span class="line"></span><br><span class="line">[Content]</span><br><span class="line">Bootable=no    # 该镜像是扩展镜像，不需要可引导</span><br><span class="line">BaseTrees=%O/base    # 获取增量的相对目录树</span><br><span class="line">Packages=...    # 安装的软件包，和Sysext相同</span><br></pre></td></tr></table></figure>
<ul>
<li>可以考虑为Sysext镜像添加对该Confext镜像的依赖关系。</li>
</ul>
<p>如果希望<code>systemd-sysext.service</code>在启动时自动导入<code>/var/lib/extensions.mutable/</code>目录下的替换文件（我们不希望USR可变），创建<code>mkosi.images/base/mkosi.extra/usr/lib/systemd/system/systemd-sysext.service.d/import.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=systemd-sysext --mutable=import</span><br><span class="line">ExecReload=</span><br><span class="line">ExecReload=systemd-sysext --mutable=import</span><br></pre></td></tr></table></figure>

<p>值得一提的是，安装Sysext&#x2F;Confext镜像时，虽然默认会触发<code>systemctl daemon-reload</code>，但是并不会触发<code>systemctl preset-all</code>、<code>systemd-tmpfiles --create</code>、<code>systemd-sysusers</code>的执行（有时候还需要重载<code>dbus.service</code>，例如<code>rtkit.service</code>这类需要在D-Bus上注册的服务），需要手动执行对应操作。</p>
<ul>
<li>启用（<code>enable</code>）Sysext镜像中提供的systemd单元的操作必须在<code>systemd-confext.service</code>没有启动时执行，确保<code>/etc/systemd/system/</code>目录下的软链接是在基础<code>/etc</code>中创建的，而不是合并Confext后的可变目录下（<code>/var/lib/extensions.mutable/</code>）。这一问题也可以通过在<code>/etc/rc.local</code>中手动添加<code>systemctl daemon-reload</code>解决。</li>
</ul>
<h4 id="（已废弃）可写的-etc"><a href="#（已废弃）可写的-etc" class="headerlink" title="（已废弃）可写的/etc/"></a>（已废弃）可写的<code>/etc/</code></h4><p>我的系统的<code>/etc/</code>是可变的，所以还需要为<code>systemd-confext.service</code>进行修改，主要是启用<code>--mutable=yes</code>可变选项和禁用<code>--noexec=no</code>不可执行脚本选项。创建<code>mkosi.images/base/mkosi.extra/usr/lib/systemd/system/systemd-confext.service.d/mutable.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=systemd-confext --mutable=yes --noexec=no</span><br><span class="line">ExecReload=</span><br><span class="line">ExecReload=systemd-confext --mutable=yes --noexec=no</span><br></pre></td></tr></table></figure>

<h4 id="动态解锁的-etc"><a href="#动态解锁的-etc" class="headerlink" title="动态解锁的/etc/"></a>动态解锁的<code>/etc/</code></h4><p>现在系统的<code>/etc/</code>也是不可变的，它的配置是这样的<code>mkosi.images/base/mkosi.extra/usr/lib/systemd/system/systemd-confext.service.d/exec.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=systemd-confext refresh --noexec=no --mutable=import</span><br><span class="line">ExecReload=</span><br><span class="line">ExecReload=systemd-confext refresh --noexec=no --mutable=import</span><br></pre></td></tr></table></figure>

<p>这意味着我们有两种动态修改<code>/etc/</code>的方式：</p>
<ol>
<li>临时执行<code>systemd-confext unmerge</code>，直接修改下层的<code>/etc/</code>目录。</li>
<li>创建<code>/var/lib/extensions.mutable/etc/</code>目录，在里面保存修改的文件后执行<code>systemd-confext refresh --noexec=no --mutable=import</code>。</li>
</ol>
<p><code>unlock-etc</code>脚本，用于方便地修改下层的<code>/etc/</code>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -ue</span><br><span class="line"></span><br><span class="line">start_confext() &#123;</span><br><span class="line">    if ! systemctl --no-block start systemd-confext.service; then</span><br><span class="line">    	printf &#x27;%s\n&#x27; &#x27;Error: Failed to queue start job for systemd-confext.service.&#x27; &gt;&amp;2</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap start_confext HUP INT QUIT ABRT TERM</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    printf &#x27;%s\n&#x27; &#x27;Unlock /etc and run command.&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$&#123;1:-&#125;&quot; ]; then</span><br><span class="line">    usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ! [ -x &quot;$(which &quot;$1&quot;)&quot; ]; then</span><br><span class="line">    printf &#x27;%s\n&#x27; &quot;Error: $1 is not executable.&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if systemctl stop systemd-confext.service; then</span><br><span class="line">    &quot;$@&quot; || &#123; printf &#x27;%s\n&#x27; &quot;Error: Failed to run $1&quot; &gt;&amp;2 &amp;&amp; exit 1; &#125;</span><br><span class="line">    systemctl --no-block start systemd-confext.service </span><br><span class="line">else</span><br><span class="line">    printf &#x27;%s\n&#x27; &#x27;Error: Failed to stop systemd-confext.service.&#x27; &gt;&amp;2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><p><code>systemd-sysext</code>和<code>systemd-confext</code>原生就支持通过<code>--mutable=ephemeral</code>选项在Overlayfs的最上层再挂载一层可写的Tmpfs，从而实现可回滚的测试操作。</p>
<p>究其原理其实不难，也就是在Tmpfs的<code>/run</code>目录下创建两个临时目录，分别用于Upperdir和Workdir，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t overlay overlay -o lowerdir=下层目录,upperdir=/run中的Upperdir,workdir=/run中的Workdir 下层目录</span><br></pre></td></tr></table></figure>
<p>一个PoC程序为<a target="_blank" rel="noopener" href="https://github.com/MoltenArmor/tmpify.sh"><code>tmpify.sh</code></a>。</p>
<p>快速进入可回滚环境<code>enter-rw</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -ue</span><br><span class="line"></span><br><span class="line">reload_or_restart() &#123;</span><br><span class="line">    systemctl --no-block reload-or-restart systemd-sysext.service systemd-confext.service</span><br><span class="line">    tmpify -r /var/lib/apt || :</span><br><span class="line">    tmpify -r /var/lib/dpkg || :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap reload_or_restart HUP INT QUIT ABRT TERM</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    printf &#x27;%s\n&#x27; &#x27;Enter testing mode with ephemeral /etc and /usr.&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_user() &#123;</span><br><span class="line">    if [ &quot;$(id -u)&quot; -ne 0 ]; then</span><br><span class="line">        echo &quot;Error: This script must be run as root.&quot; &gt;&amp;2</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ &quot;$#&quot; -ne 0 ]; then</span><br><span class="line">    usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">check_user</span><br><span class="line"></span><br><span class="line">if systemd-confext refresh --noexec=no --mutable=ephemeral-import &amp;&amp; systemd-sysext refresh --mutable=ephemeral; then</span><br><span class="line">    if tmpify /var/lib/apt &amp;&amp; tmpify /var/lib/dpkg; then</span><br><span class="line">        :</span><br><span class="line">    else</span><br><span class="line">        printf &#x27;%s\n&#x27; &#x27;Error: Failed to tmpify /var/lib/apt or /var/lib/dpkg.&#x27; &gt;&amp;2</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    printf &#x27;%s\n&#x27; &#x27;Error: Failed to refresh systemd-confext or systemd-sysext.&#x27; &gt;&amp;2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>退出<code>exit-rw</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -ue</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    printf &#x27;%s\n&#x27; &#x27;Exit testing mode and restore /etc and /usr.&#x27;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_user() &#123;</span><br><span class="line">    if [ &quot;$(id -u)&quot; -ne 0 ]; then</span><br><span class="line">        echo &quot;Error: This script must be run as root.&quot; &gt;&amp;2</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ &quot;$#&quot; -ne 0 ]; then</span><br><span class="line">    usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">check_user</span><br><span class="line"></span><br><span class="line">systemctl --no-block reload-or-restart systemd-confext.service systemd-sysext.service</span><br><span class="line"></span><br><span class="line">tmpify -r /var/lib/apt || :</span><br><span class="line">tmpify -r /var/lib/dpkg || :</span><br></pre></td></tr></table></figure>

<h4 id="保留软件包元数据"><a href="#保留软件包元数据" class="headerlink" title="保留软件包元数据"></a>保留软件包元数据</h4><p>我希望在镜像中保留软件包元数据，因此在<code>mkosi.finalize.chroot</code>脚本中写入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -ue</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/share/factory/var/lib/apt /usr/share/factory/var/lib/dpkg &amp;&amp; \</span><br><span class="line">cp --archive --no-target-directory --update=none /var/lib/apt /usr/share/factory/var/lib/apt &amp;&amp; \</span><br><span class="line">cp --archive --no-target-directory --update=none /var/lib/dpkg /usr/share/factory/var/lib/dpkg</span><br></pre></td></tr></table></figure>
<p>然后写入<code>/etc/rc.local</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rpf --update=all /usr/share/factory/var / &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>我不认为<code>/var/lib/apt/extended_states</code>和<code>/var/lib/dpkg/</code>是会变化的，因为安装软件包在我的系统上是不可能的，因此<code>cp</code>使用了<code>--update=all</code>选项。</li>
</ul>
<h2 id="系统文件释放"><a href="#系统文件释放" class="headerlink" title="系统文件释放"></a>系统文件释放</h2><p><code>systemd-tmpfiles</code>会将<code>/usr/share/factory/</code>目录视为出厂文件目录，并按照配置拷贝或链接到该目录下的文件，从而释放出根文件系统。因此，我们需要在构建时，把非<code>/usr</code>的文件全部移动到这个目录下，具体来说，这是通过<code>mkosi.finalize</code>这个钩子脚本实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -ue</span><br><span class="line"></span><br><span class="line"># --update=none是必要的，因为有些发行版本身就会在这里提供出厂文件，我们不必覆盖</span><br><span class="line"># 这里只写了/etc，你也可以考虑额外移动/var</span><br><span class="line">mkdir -p &quot;$&#123;BUILDROOT&#125;/usr/share/factory/etc&quot; &amp;&amp; \</span><br><span class="line">cp -aT --update=none &quot;$&#123;BUILDROOT&#125;/etc&quot; &quot;$&#123;BUILDROOT&#125;/usr/share/factory/etc&quot;</span><br></pre></td></tr></table></figure>
<p>这等价于<code>mkosi.finalize.chroot</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -ue</span><br><span class="line"></span><br><span class="line"># --update=none是必要的，因为有些发行版本身就会在这里提供出厂文件，我们不必覆盖</span><br><span class="line"># 这里只写了/etc，你也可以考虑额外移动/var</span><br><span class="line">mkdir -p &quot;/usr/share/factory/etc&quot; &amp;&amp; \</span><br><span class="line">cp -aT --update=none &quot;/etc&quot; &quot;/usr/share/factory/etc&quot;</span><br></pre></td></tr></table></figure>
<p>于是，我们便可以在<code>mkosi.images/base/mkosi.extra/usr/lib/tmpfiles.d/</code>中创建各种<code>systemd-tmpfiles</code>的配置文件了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L /etc/os-release - - - - ../usr/lib/os-release</span><br><span class="line">L+ /etc/mtab - - - - ../proc/self/mounts</span><br></pre></td></tr></table></figure>
<p>这两个文件是POSIX标准中至关重要的文件，因此务必确保存在。</p>
<p>不过，为了省力，我没有采用完全使用<code>systemd-tmpfiles</code>生成的思路（因为这样要编写太多配置文件了，而我太懒了），因此，我选择了一种取巧的办法：为第一次启动时进行初始化的<code>systemd-firstboot.service</code>创建了一条<code>ExecStartPre=</code>钩子：</p>
<p><code>mkosi.images/base/mkosi.extra/usr/lib/systemd/system/systemd-firstboot.service.d/etc.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStartPre=cp -rpn /usr/share/factory/etc /</span><br></pre></td></tr></table></figure>
<p>这样，在系统首次启动时，便会触发该命令的执行，确保从<code>/usr/share/factory/</code>中将系统需要的所有配置文件都释放出来，省了不少力气。</p>
<p>此外，在系统A&#x2F;B更新后，也需要再次从<code>/usr/share/factory/</code>释放文件，这可以通过为<code>systemd-update-done.service</code>服务挂钩实现，具体来说，就是编写这样一个服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">DefaultDependencies=no</span><br><span class="line">Conflicts=shutdown.target</span><br><span class="line">Before=shutdown.target</span><br><span class="line">Before=systemd-update-done.service</span><br><span class="line">ConditionNeedsUpdate=/etc</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=cp -rpn /usr/share/factory/etc /</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=systemd-update-done.service</span><br></pre></td></tr></table></figure>

<h2 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h2><p>在systemd V257，我们终于迎来了<code>systemd-sysupdate</code>与<code>mkosi</code>的集成，因此，我们只需要为<code>mkosi</code>编写<code>mkosi.sysupdate</code>配置，即可将<code>mkosi</code>用作进行系统A&#x2F;B更新的工具。</p>
<p><code>mkosi.sysupdate</code>下的<code>.transfer</code>文件的格式与<code>systemd-sysupdate</code>的标准要求没什么区别，但是特别需要注意的是这两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Source]</span><br><span class="line">Path=/</span><br><span class="line">PathRelativeTo=explicit</span><br></pre></td></tr></table></figure>
<p>这代表着由<code>mkosi</code>确定更新源的地址，是<code>systemd-sysupdate</code>和<code>mkosi</code>集成的关键。</p>
<p>其它的内容没什么特别的，详情请参考<code>systemd-sysupdate</code>的手册。</p>
<h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>要使用中文Locale，可以直接安装预编译好的<code>locales-all</code>包，也可以选择创建<code>mkosi.postinst.chroot</code>脚本，写入编译逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;/^# C.UTF-8.*/c\C.UTF-8 UTF-8&#x27; /etc/locale.gen &amp;&amp; \</span><br><span class="line">sed -i &#x27;/^# en_US.UTF-8.*/c\en_US.UTF-8 UTF-8&#x27; /etc/locale.gen &amp;&amp; \</span><br><span class="line">sed -i &#x27;/^# zh_CN.UTF-8.*/c\zh_CN.UTF-8 UTF-8&#x27; /etc/locale.gen &amp;&amp; \</span><br><span class="line">locale-gen</span><br></pre></td></tr></table></figure>

<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><h3 id="修复regulatory-db"><a href="#修复regulatory-db" class="headerlink" title="修复regulatory.db"></a>修复<code>regulatory.db</code></h3><p>发现明明安装了<code>wireless-regdb</code>包，还是会报告<code>failed to load regulatory.db</code>。</p>
<p>猜想原因可能是<code>/usr</code>和<code>/etc</code>不在同一个分区。创建<code>mkosi.postinst.chroot</code>脚本，写入逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf regulatory.db-debian /usr/lib/firmware/regulatory.db</span><br><span class="line">ln -sf regulatory.db-debian.p7s /usr/lib/firmware/regulatory.db.p7s</span><br></pre></td></tr></table></figure>

<h2 id="镜像口味"><a href="#镜像口味" class="headerlink" title="镜像口味"></a>镜像口味</h2><p>我们会希望为镜像编写不同微调的“口味”，例如让基础镜像带上桌面环境之类的。<code>mkosi</code>整理这些内容的方式是<code>mkosi.profiles</code>，每个Profile目录的结构都和项目根目录一致，除了不能嵌套包含<code>mkosi.profiles</code>目录以外。</p>
<h2 id="Live系统"><a href="#Live系统" class="headerlink" title="Live系统"></a>Live系统</h2><p>要构建Live系统，只需要修改内核命令行参数，当然，我们可以通过UKI Profile在UKI中封装额外的内核命令行参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">    ID=live</span><br><span class="line">    TITLE=Live System</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        root=tmpfs</span><br><span class="line">        rd.systemd.mask=systemd-repart.service</span><br><span class="line">        systemd.mask=systemd-repart.service</span><br><span class="line">        systemd.firstboot=no</span><br><span class="line">        # Agetty的凭据，启用Root的自动登录</span><br><span class="line">        systemd.set_credential=agetty.autologin:root</span><br><span class="line">        # 跳过身份验证</span><br><span class="line">        systemd.set_credential=login.noauth:yes</span><br><span class="line">        systemd.journald.forward_to_console=1</span><br><span class="line">        systemd.journald.max_level_console=warning</span><br><span class="line">        SYSTEMD_SULOGIN_FORCE=1</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="Debug模式"><a href="#Debug模式" class="headerlink" title="Debug模式"></a>Debug模式</h2><p>这会导致超多输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=debug</span><br><span class="line">        TITLE=Boot with debug mode</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        debug</span><br><span class="line">        systemd.log_level=debug</span><br><span class="line">        systemd.journald.forward_to_console=1</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="STM服务端"><a href="#STM服务端" class="headerlink" title="STM服务端"></a>STM服务端</h2><p>通过NVME-TCP实现将根文件系统服务出去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=storagetm</span><br><span class="line">        TITLE=Storage Target Mode with Public Access</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        rd.systemd.unit=storage-target-mode.target</span><br><span class="line">        ip=any</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="救援模式"><a href="#救援模式" class="headerlink" title="救援模式"></a>救援模式</h2><p>不必多说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=emergency</span><br><span class="line">        TITLE=Boot into Emergency Mode</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        systemd.unit=emergency.target</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="Initrd断点"><a href="#Initrd断点" class="headerlink" title="Initrd断点"></a>Initrd断点</h2><p>在Initrd打断启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=break</span><br><span class="line">        TITLE=Boot into Initrd</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        rd.systemd.break=pre-switch-root</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="出厂化"><a href="#出厂化" class="headerlink" title="出厂化"></a>出厂化</h2><p>为<code>systemd-repart</code>分区配置<code>FactoryReset=yes</code>，然后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=factory-reset</span><br><span class="line">        TITLE=Reset System to Factory Defaults [CAUTION!]</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        systemd.factory_reset=1</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>
<p>彻底出厂化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[UKIProfile]</span><br><span class="line">Profile=</span><br><span class="line">        ID=factory-reset-tpm2-clear</span><br><span class="line">        TITLE=Reset System to Factory Defaults + TPM2 Clear [CAUTION!]</span><br><span class="line"></span><br><span class="line">Cmdline=</span><br><span class="line">        rd.systemd.unit=factory-reset.target</span><br><span class="line"></span><br><span class="line">SignExpectedPcr=no</span><br></pre></td></tr></table></figure>

<h2 id="一些截图"><a href="#一些截图" class="headerlink" title="一些截图"></a>一些截图</h2><p>构建系统镜像：</p>
<p><img src="/images/not-so-immutable-os1.png" alt="not-so-immutable-os1.png"></p>
<p><img src="/images/not-so-immutable-os2.png" alt="not-so-immutable-os2.png"></p>
<p>这个<code>.raw</code>结尾的就是我们的系统镜像了，可以直接<code>truncate -s</code>调整大小后用于虚拟机：</p>
<p><img src="/images/not-so-immutable-os3.png" alt="[not-so-immutable-os3.png]"></p>
<p>引导界面：</p>
<p><img src="/images/not-so-immutable-os4.png" alt="[not-so-immutable-os4.png]"></p>
<p>在安装好的系统中，安装<code>mkosi</code>，克隆系统代码，进行自举的A&#x2F;B更新：</p>
<p><img src="/images/not-so-immutable-os5.png" alt="not-so-immutable-os5.png"></p>
<p><img src="/images/not-so-immutable-os6.png" alt="not-so-immutable-os6.png"></p>
<p><img src="/images/not-so-immutable-os7.png" alt="not-so-immutable-os7.png"></p>
<p>更新完成的引导界面：</p>
<p><img src="/images/not-so-immutable-os8.png" alt="not-so-immutable-os8.png"></p>
<p>导入Incus的系统扩展镜像：</p>
<p><img src="/images/not-so-immutable-os9.png" alt="not-so-immutable-os9.png"></p>
<p><img src="/images/not-so-immutable-os10.png" alt="not-so-immutable-os10.png"></p>
<p>如此一来就可以使用Incus了：</p>
<p><img src="/images/not-so-immutable-os11.png" alt="not-so-immutable-os11.png"></p>
<p>最后留一张分区表的图片：</p>
<p><img src="/images/not-so-immutable-os12.png" alt="not-so-immutable-os12.png"></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/12/02/Init%E7%B3%BB%E7%BB%9F%E5%8E%86%E4%BB%A3%E8%AE%B0-SysV/" rel="prev" title="Init系统历代记-SysV">
                  <i class="fa fa-angle-left"></i> Init系统历代记-SysV
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/25/Init%E7%B3%BB%E7%BB%9F%E5%8E%86%E4%BB%A3%E8%AE%B0-Upstart/" rel="next" title="Init系统历代记-Upstart">
                  Init系统历代记-Upstart <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Molten_Armor</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
